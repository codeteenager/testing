import{_ as l,o as i,c as a,Q as e}from"./chunks/framework.29d073da.js";const p="/testing/guide/1.jpg",s="/testing/guide/2.jpg",t="/testing/guide/3.jpg",b=JSON.parse('{"title":"前端测试基础概念","description":"","frontmatter":{},"headers":[],"relativePath":"guide/index.md","filePath":"guide/index.md","lastUpdated":1698770947000}'),o={name:"guide/index.md"},n=e('<h1 id="前端测试基础概念" tabindex="-1">前端测试基础概念 <a class="header-anchor" href="#前端测试基础概念" aria-label="Permalink to &quot;前端测试基础概念&quot;">​</a></h1><h2 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h2><p>对于稍微有一些开发经验的同学在开发过程中总会经历下面类似的问题。</p><ul><li>每次在版本发布上线之前，在电脑前蹲上好几个小时甚至是更长时间对你的应用进行测试，这个过程非常枯燥而痛苦</li><li>当代码的复杂度达到了一定的级别，当维护者的数量不止你一个，你应该会逐渐察觉到你在开发新功能或修复bug的时候，会变得越发小心翼翼，即使代码看起来没什么问题，但你心里还是会犯嘀咕：这个Feature会不会带来其他Bug？这个Fix会不会引入其他&quot;Feature&quot;？</li><li>当你想要对项目中的代码进行重构的时候，你会花费大量的时间进行回归测试</li></ul><p>以上这些问题都是由于大多数开发者所使用最基本的手动测试的方式所带来的问题，解决它的根本原因就在于引入自动化测试方案。</p><p>什么是应用程序测试？</p><p>一个简单的定义是：应用程序测试是指检查程序运行过程是否正确。</p><p>在日常的开发中，代码的完工其实并不等于开发的完工。如果没有测试，不能保证代码能够正常运行。</p><p>如何进行应用程序测试？</p><ul><li>手动测试：通过测试人员与应用程序的交互来检查是否正常工作。</li><li>自动化测试：编写应用程序来替代人工检验。</li></ul><h2 id="手动测试" tabindex="-1">手动测试 <a class="header-anchor" href="#手动测试" aria-label="Permalink to &quot;手动测试&quot;">​</a></h2><p>每一个称职的开发人员都懂得手动测试代码。在编写完源代码之后，下一步理所当然就是去手动测试它。</p><p>手动测试的优势在于足够简单灵活，但是缺点也很明显：</p><ul><li>手动不适合大型项目</li><li>忘记测试某项功能</li><li>大部分时间都在做回归测试</li></ul><p>虽然有一部分手动测试时间是花在测试新特性上，但是大部分时间还是用来检查之前的特性是否仍正常工作。这种测试被称为回归测试。回归测试对人类来说是非常困难的任务-----它们是重复性的，要求投入更多注意力，而且没有创造性的输入。总之，这种测试太枯燥了。幸运的是，计算机特别擅长此类工作，这也是自动化测试可以大展身手的地方！</p><h2 id="自动化测试" tabindex="-1">自动化测试 <a class="header-anchor" href="#自动化测试" aria-label="Permalink to &quot;自动化测试&quot;">​</a></h2><p>自动化测试（automated testing）是利用计算机程序检查软件是否运行正常的测试方法。换句话说，就是用其他额外的代码检查被测软件的代码。当测试代码编写完之后，就可以不费吹灰之力的进行无数次重复测试。</p><p>可使用许多种不同的方法来编写自动化测试脚本。</p><ul><li>可以编写浏览器自动执行的程序</li><li>可以直接调用源代码里的函数</li><li>也可以直接对比程序渲染之后的截图</li></ul><p>虽然每一种方法的优势各不相同，但它们有一大共同点：相比手动测试而言节省了大量时间以及提高了程序的稳定性。</p><p>当然不仅如此，自动化测试还有很多优点，比如：</p><ul><li>今早的发现程序的bug和不足</li><li>增强程序员对程序健壮性，稳定性的信心</li><li>改进设计</li><li>快速反馈，减少调试时间</li><li>促进重构</li></ul><p>当然了自动化测试不可能保证一个程序是完全正确的，而且事实上，在实际开发过程中，编写自动化测试代码通常是开发人员不太喜欢的一个环节。大多数情况下，前端开发人员在开发完一项功能后，只是打开浏览器手动点击，查看效果是否正确，之后就很少对该块代码进行管理。造成这个情况的原因主要有两个：</p><ul><li>一个是业务繁忙，没有时间进行测试的编写</li><li>另一个是不知道如何编写测试</li></ul><p>但这些问题不应该作为我们掌握前端自动化测试的绊脚石，而且一旦掌握了前端自动化测试方案无论是对应对大型项目的开发还是升职加薪都是有益的。</p><p>所以：</p><ul><li>如何进行前端应用测试？</li><li>应用程序中哪些部分应该被优先测试？</li><li>这些部分应该使用什么方法进行测试？</li><li>一些特殊场景下的测试问题该怎么解决？</li><li>我们如何从一开始就整合不同的测试技巧，编制一个高效的测试套件？</li></ul><h2 id="测试分类" tabindex="-1">测试分类 <a class="header-anchor" href="#测试分类" aria-label="Permalink to &quot;测试分类&quot;">​</a></h2><p>前端开发最常见的测试主要是以下几种：</p><ul><li>单元测试：验证独立的单元是否正常工作</li><li>集成测试：验证多个单元协同工作</li><li>端到端测试：从用户角度以机器的方式在真实浏览器环境验证应用交互</li><li>快照测试：验证程序的UI变化</li></ul><h2 id="单元测试" tabindex="-1">单元测试 <a class="header-anchor" href="#单元测试" aria-label="Permalink to &quot;单元测试&quot;">​</a></h2><p>单元测试是对应用程序最小的部分（单元）运行测试的过程。通常，测试的单元是函数，但在前端应用中，组件也是被测单元。</p><p>单元测试可以单独调用源代码中的函数并断言其行为是否正确。</p><p><img src="'+p+'" alt=""></p><p>与端到端测试不同，单元测试运行速度很快，只需要几秒钟的运行时间，因此你可以在每次代码变更后都运行单元测试，从而快速得到变更是否破坏现有功能的反馈。</p><p>单元测试应该避免依赖性问题，比如不存取数据库、不访问网络等等，而是使用工具虚拟出运行环境。这种虚拟使得测试成本最小化，不用花大力气搭建各种测试环境。</p><p>单元测试的优点：</p><ul><li>提升代码质量，减少Bug</li><li>快速反馈，减少调试时间</li><li>让代码维护更容易</li><li>有助于代码的模块化设计</li><li>代码覆盖率高</li></ul><p>单元测试的缺点：</p><ul><li>由于单元测试是独立的，所以无法保证多个单元运行到一起是否正确。</li></ul><p>常见的JavaScript单元测试：</p><ul><li>Jest</li><li>Mocha</li><li>Jasmine</li><li>Karma</li><li>ava</li><li>Tape</li></ul><p>Mocha跟Jest是目前最火的两个单元测试框架，基本上目前前端单元测试就在这两个库之间选了。总的来说就是Jest功能齐全，配置方便，Mocha灵活自由，自由配置。两者功能覆盖范围粗略可以表示为：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">Jest </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> Mocha</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">Chai</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">Sinon</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">mockserver</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">istanbul</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">Jest </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> Mocha</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">Chai</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">Sinon</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">mockserver</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">istanbul</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>实际使用来看，目前最火的是Jest，推荐使用。</p><h2 id="集成测试" tabindex="-1">集成测试 <a class="header-anchor" href="#集成测试" aria-label="Permalink to &quot;集成测试&quot;">​</a></h2><p>人们定义集成测试的方式并不相同，尤其是对于前端。有些人认为在浏览器环境上运行的测试是集成测试。有些人认为对具有模块依赖性的单元进行的任何测试都是集成测试。也有些人认为任何完全渲染的组件测试都是集成测试。</p><p><img src="'+s+'" alt=""></p><p>优点：</p><ul><li>由于是从用户使用角度出发，更容易获得软件使用过程中的正确性</li><li>集成测试相对于写了软件的说明文档</li><li>由于不关注底层代码实现细节，所以更有利于快速重构</li><li>相比单元测试，集成测试的开发速度要更快一些</li></ul><p>缺点：</p><ul><li>测试失败的时候无法快速定位问题</li><li>代码覆盖率较低</li><li>速度比单元测试要慢</li></ul><h2 id="端到端测试-e2e" tabindex="-1">端到端测试(E2E) <a class="header-anchor" href="#端到端测试-e2e" aria-label="Permalink to &quot;端到端测试(E2E)&quot;">​</a></h2><p>E2E（end to end）端到端测试是最直观可以理解的测试类型。在前端应用程序中，端到端测试可以从用户的视角通过浏览器自动检查应用程序是否正常工作。</p><p>想象一下，你正在编写一个计算机应用程序，并且你想测试两个数求和的运算方法是否正确。你可以编写一个端到端测试，打开浏览器，加载计算器应用程序，单击1按钮，单击加号+按钮，再次单击1按钮，单击等号=，最后检查屏幕是否显示正确结果2.</p><p><img src="'+t+'" alt=""></p><p>编写完一个端到端测试后，可以根据自己的需求随时运行它。想象一下，相比执行数百次同样的手动测试，这样一套测试代码可以节省多少时间！</p><p>优点：</p><ul><li>真实的测试环境，更容易获得程序的信息</li></ul><p>缺点：</p><ul><li>首先，端到端测试运行不够快。启动浏览器需要占用几秒钟，网站响应速度又慢。通常一套端到端测试需要30分钟的运行时间。如果应用程序完全依赖于端到端测试，那么测试套件将需要数小时的运行时间。</li><li>端到端测试的另一个问题是调试起来比较困难。要调试端到端测试，需要打开浏览器并逐步完成用户操作以重现bug。本地运行这个调试过程就已经够糟糕了，如果测试是在持续集成服务器上失败而不是本地计算机上失败，那么整个调试过程会变得更加糟糕。</li></ul><p>一些流行的端到端测试框架：</p><ul><li>Cypress</li><li>Nightwatch</li><li>WebdriverIO</li><li>playwright</li></ul><p>最流行的是Cypress。</p>',64),r=[n];function c(u,d,h,m,_,E){return i(),a("div",null,r)}const y=l(o,[["render",c]]);export{b as __pageData,y as default};
