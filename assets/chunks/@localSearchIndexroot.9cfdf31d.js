const t='{"documentCount":8,"nextId":8,"documentIds":{"0":"/testing/guide/#前端测试基础概念","1":"/testing/guide/#概述","2":"/testing/guide/#手动测试","3":"/testing/guide/#自动化测试","4":"/testing/guide/#测试分类","5":"/testing/guide/#单元测试","6":"/testing/guide/#集成测试","7":"/testing/guide/#端到端测试-e2e"},"fieldIds":{"title":0,"titles":1,"text":2},"fieldLength":{"0":[1,1,1],"1":[1,1,31],"2":[1,1,21],"3":[1,1,48],"4":[1,1,10],"5":[1,1,52],"6":[1,1,18],"7":[3,1,45]},"averageFieldLength":[1.25,1,28.25],"storedFields":{"0":{"title":"前端测试基础概念","titles":[]},"1":{"title":"概述","titles":["前端测试基础概念"]},"2":{"title":"手动测试","titles":["前端测试基础概念"]},"3":{"title":"自动化测试","titles":["前端测试基础概念"]},"4":{"title":"测试分类","titles":["前端测试基础概念"]},"5":{"title":"单元测试","titles":["前端测试基础概念"]},"6":{"title":"集成测试","titles":["前端测试基础概念"]},"7":{"title":"端到端测试(E2E)","titles":["前端测试基础概念"]}},"dirtCount":0,"index":[["最流行的是cypress",{"2":{"7":1}}],["最后检查屏幕是否显示正确结果2",{"2":{"7":1}}],["playwright",{"2":{"7":1}}],["webdriverio",{"2":{"7":1}}],["nightwatch",{"2":{"7":1}}],["cypress",{"2":{"7":1}}],["那么整个调试过程会变得更加糟糕",{"2":{"7":1}}],["那么测试套件将需要数小时的运行时间",{"2":{"7":1}}],["本地运行这个调试过程就已经够糟糕了",{"2":{"7":1}}],["需要打开浏览器并逐步完成用户操作以重现bug",{"2":{"7":1}}],["要调试端到端测试",{"2":{"7":1}}],["要求投入更多注意力",{"2":{"2":1}}],["网站响应速度又慢",{"2":{"7":1}}],["启动浏览器需要占用几秒钟",{"2":{"7":1}}],["首先",{"2":{"7":1}}],["更容易获得程序的信息",{"2":{"7":1}}],["更容易获得软件使用过程中的正确性",{"2":{"6":1}}],["真实的测试环境",{"2":{"7":1}}],["再次单击1按钮",{"2":{"7":1}}],["单击等号=",{"2":{"7":1}}],["单击加号+按钮",{"2":{"7":1}}],["单击1按钮",{"2":{"7":1}}],["单元",{"2":{"5":1}}],["单元测试的缺点",{"2":{"5":1}}],["单元测试的优点",{"2":{"5":1}}],["单元测试应该避免依赖性问题",{"2":{"5":1}}],["单元测试运行速度很快",{"2":{"5":1}}],["单元测试可以单独调用源代码中的函数并断言其行为是否正确",{"2":{"5":1}}],["单元测试是对应用程序最小的部分",{"2":{"5":1}}],["单元测试",{"0":{"5":1},"2":{"4":1}}],["加载计算器应用程序",{"2":{"7":1}}],["打开浏览器",{"2":{"7":1}}],["并且你想测试两个数求和的运算方法是否正确",{"2":{"7":1}}],["想象一下",{"2":{"7":2}}],["end",{"2":{"7":2}}],["e2e",{"0":{"7":1},"2":{"7":1}}],["速度比单元测试要慢",{"2":{"6":1}}],["缺点",{"2":{"6":1,"7":1}}],["相比执行数百次同样的手动测试",{"2":{"7":1}}],["相比单元测试",{"2":{"6":1}}],["相比手动测试而言节省了大量时间以及提高了程序的稳定性",{"2":{"3":1}}],["由于不关注底层代码实现细节",{"2":{"6":1}}],["由于是从用户使用角度出发",{"2":{"6":1}}],["由于单元测试是独立的",{"2":{"5":1}}],["优点",{"2":{"6":1,"7":1}}],["也有些人认为任何完全渲染的组件测试都是集成测试",{"2":{"6":1}}],["也可以直接对比程序渲染之后的截图",{"2":{"3":1}}],["有些人认为对具有模块依赖性的单元进行的任何测试都是集成测试",{"2":{"6":1}}],["有些人认为在浏览器环境上运行的测试是集成测试",{"2":{"6":1}}],["有助于代码的模块化设计",{"2":{"5":1}}],["尤其是对于前端",{"2":{"6":1}}],["人们定义集成测试的方式并不相同",{"2":{"6":1}}],["推荐使用",{"2":{"5":1}}],["目前最火的是jest",{"2":{"5":1}}],["1实际使用来看",{"2":{"5":1}}],["===",{"2":{"5":2}}],["两者功能覆盖范围粗略可以表示为",{"2":{"5":1}}],["自由配置",{"2":{"5":1}}],["自动化测试还有很多优点",{"2":{"3":1}}],["自动化测试",{"0":{"3":1},"2":{"1":1,"3":1}}],["配置方便",{"2":{"5":1}}],["总的来说就是jest功能齐全",{"2":{"5":1}}],["总之",{"2":{"2":1}}],["基本上目前前端单元测试就在这两个库之间选了",{"2":{"5":1}}],["to",{"2":{"7":1}}],["tape",{"2":{"5":1}}],["testing",{"2":{"3":1}}],["ava",{"2":{"5":1}}],["automated",{"2":{"3":1}}],["karma",{"2":{"5":1}}],["jsjest",{"2":{"5":1}}],["jasmine",{"2":{"5":1}}],["jest",{"2":{"5":1}}],["mocha+chai+sinon+mockserver+istanbul",{"2":{"5":1}}],["mocha+chai+sinon+mockserver+istanbuljest",{"2":{"5":1}}],["mocha灵活自由",{"2":{"5":1}}],["mocha跟jest是目前最火的两个单元测试框架",{"2":{"5":1}}],["mocha",{"2":{"5":1}}],["常见的javascript单元测试",{"2":{"5":1}}],["代码覆盖率较低",{"2":{"6":1}}],["代码覆盖率高",{"2":{"5":1}}],["代码的完工其实并不等于开发的完工",{"2":{"1":1}}],["让代码维护更容易",{"2":{"5":1}}],["减少bug",{"2":{"5":1}}],["减少调试时间",{"2":{"3":1,"5":1}}],["提升代码质量",{"2":{"5":1}}],["而是使用工具虚拟出运行环境",{"2":{"5":1}}],["而且一旦掌握了前端自动化测试方案无论是对应对大型项目的开发还是升职加薪都是有益的",{"2":{"3":1}}],["而且事实上",{"2":{"3":1}}],["而且没有创造性的输入",{"2":{"2":1}}],["不用花大力气搭建各种测试环境",{"2":{"5":1}}],["不访问网络等等",{"2":{"5":1}}],["不能保证代码能够正常运行",{"2":{"1":1}}],["从而快速得到变更是否破坏现有功能的反馈",{"2":{"5":1}}],["从用户角度以机器的方式在真实浏览器环境验证应用交互",{"2":{"4":1}}],["因此你可以在每次代码变更后都运行单元测试",{"2":{"5":1}}],["只需要几秒钟的运行时间",{"2":{"5":1}}],["只是打开浏览器手动点击",{"2":{"3":1}}],["与端到端测试不同",{"2":{"5":1}}],["组件也是被测单元",{"2":{"5":1}}],["测试失败的时候无法快速定位问题",{"2":{"6":1}}],["测试的单元是函数",{"2":{"5":1}}],["测试分类",{"0":{"4":1}}],["通常一套端到端测试需要30分钟的运行时间",{"2":{"7":1}}],["通常",{"2":{"5":1}}],["通过测试人员与应用程序的交互来检查是否正常工作",{"2":{"1":1}}],["运行测试的过程",{"2":{"5":1}}],["快照测试",{"2":{"4":1}}],["快速反馈",{"2":{"3":1,"5":1}}],["端到端测试的另一个问题是调试起来比较困难",{"2":{"7":1}}],["端到端测试运行不够快",{"2":{"7":1}}],["端到端测试可以从用户的视角通过浏览器自动检查应用程序是否正常工作",{"2":{"7":1}}],["端到端测试是最直观可以理解的测试类型",{"2":{"7":1}}],["端到端测试",{"0":{"7":1},"2":{"4":1}}],["验证程序的ui变化",{"2":{"4":1}}],["验证多个单元协同工作",{"2":{"4":1}}],["验证独立的单元是否正常工作",{"2":{"4":1}}],["集成测试的开发速度要更快一些",{"2":{"6":1}}],["集成测试相对于写了软件的说明文档",{"2":{"6":1}}],["集成测试",{"0":{"6":1},"2":{"4":1}}],["编制一个高效的测试套件",{"2":{"3":1}}],["编写完一个端到端测试后",{"2":{"7":1}}],["编写自动化测试代码通常是开发人员不太喜欢的一个环节",{"2":{"3":1}}],["编写应用程序来替代人工检验",{"2":{"1":1}}],["我们如何从一开始就整合不同的测试技巧",{"2":{"3":1}}],["一些流行的端到端测试框架",{"2":{"7":1}}],["一些特殊场景下的测试问题该怎么解决",{"2":{"3":1}}],["一个是业务繁忙",{"2":{"3":1}}],["一个简单的定义是",{"2":{"1":1}}],["应用程序中哪些部分应该被优先测试",{"2":{"3":1}}],["应用程序测试是指检查程序运行过程是否正确",{"2":{"1":1}}],["所以更有利于快速重构",{"2":{"6":1}}],["所以无法保证多个单元运行到一起是否正确",{"2":{"5":1}}],["所以",{"2":{"3":1}}],["另一个是不知道如何编写测试",{"2":{"3":1}}],["没有时间进行测试的编写",{"2":{"3":1}}],["造成这个情况的原因主要有两个",{"2":{"3":1}}],["之后就很少对该块代码进行管理",{"2":{"3":1}}],["查看效果是否正确",{"2":{"3":1}}],["前端开发最常见的测试主要是以下几种",{"2":{"4":1}}],["前端开发人员在开发完一项功能后",{"2":{"3":1}}],["前端测试基础概念",{"0":{"0":1},"1":{"1":1,"2":1,"3":1,"4":1,"5":1,"6":1,"7":1}}],["大多数情况下",{"2":{"3":1}}],["大部分时间都在做回归测试",{"2":{"2":1}}],["促进重构",{"2":{"3":1}}],["改进设计",{"2":{"3":1}}],["稳定性的信心",{"2":{"3":1}}],["增强程序员对程序健壮性",{"2":{"3":1}}],["今早的发现程序的bug和不足",{"2":{"3":1}}],["比如不存取数据库",{"2":{"5":1}}],["比如",{"2":{"3":1}}],["虽然每一种方法的优势各不相同",{"2":{"3":1}}],["虽然有一部分手动测试时间是花在测试新特性上",{"2":{"2":1}}],["可以根据自己的需求随时运行它",{"2":{"7":1}}],["可以直接调用源代码里的函数",{"2":{"3":1}}],["可以编写浏览器自动执行的程序",{"2":{"3":1}}],["可使用许多种不同的方法来编写自动化测试脚本",{"2":{"3":1}}],["就可以不费吹灰之力的进行无数次重复测试",{"2":{"3":1}}],["就是用其他额外的代码检查被测软件的代码",{"2":{"3":1}}],["换句话说",{"2":{"3":1}}],["是利用计算机程序检查软件是否运行正常的测试方法",{"2":{"3":1}}],["计算机特别擅长此类工作",{"2":{"2":1}}],["幸运的是",{"2":{"2":1}}],["它们是重复性的",{"2":{"2":1}}],["回归测试对人类来说是非常困难的任务",{"2":{"2":1}}],["这样一套测试代码可以节省多少时间",{"2":{"7":1}}],["这种虚拟使得测试成本最小化",{"2":{"5":1}}],["这种测试太枯燥了",{"2":{"2":1}}],["这种测试被称为回归测试",{"2":{"2":1}}],["这些部分应该使用什么方法进行测试",{"2":{"3":1}}],["这也是自动化测试可以大展身手的地方",{"2":{"2":1}}],["这个fix会不会引入其他",{"2":{"1":1}}],["这个feature会不会带来其他bug",{"2":{"1":1}}],["这个过程非常枯燥而痛苦",{"2":{"1":1}}],["忘记测试某项功能",{"2":{"2":1}}],["手动不适合大型项目",{"2":{"2":1}}],["手动测试的优势在于足够简单灵活",{"2":{"2":1}}],["手动测试",{"0":{"2":1},"2":{"1":1}}],["但在前端应用中",{"2":{"5":1}}],["但这些问题不应该作为我们掌握前端自动化测试的绊脚石",{"2":{"3":1}}],["但它们有一大共同点",{"2":{"3":1}}],["但是大部分时间还是用来检查之前的特性是否仍正常工作",{"2":{"2":1}}],["但是缺点也很明显",{"2":{"2":1}}],["但你心里还是会犯嘀咕",{"2":{"1":1}}],["下一步理所当然就是去手动测试它",{"2":{"2":1}}],["每一个称职的开发人员都懂得手动测试代码",{"2":{"2":1}}],["每次在版本发布上线之前",{"2":{"1":1}}],["如果测试是在持续集成服务器上失败而不是本地计算机上失败",{"2":{"7":1}}],["如果应用程序完全依赖于端到端测试",{"2":{"7":1}}],["如果没有测试",{"2":{"1":1}}],["如何进行前端应用测试",{"2":{"3":1}}],["如何进行应用程序测试",{"2":{"1":1}}],["在前端应用程序中",{"2":{"7":1}}],["在实际开发过程中",{"2":{"3":1}}],["在编写完源代码之后",{"2":{"2":1}}],["在日常的开发中",{"2":{"1":1}}],["在电脑前蹲上好几个小时甚至是更长时间对你的应用进行测试",{"2":{"1":1}}],["什么是应用程序测试",{"2":{"1":1}}],["解决它的根本原因就在于引入自动化测试方案",{"2":{"1":1}}],["以上这些问题都是由于大多数开发者所使用最基本的手动测试的方式所带来的问题",{"2":{"1":1}}],["你可以编写一个端到端测试",{"2":{"7":1}}],["你正在编写一个计算机应用程序",{"2":{"7":1}}],["你会花费大量的时间进行回归测试",{"2":{"1":1}}],["你应该会逐渐察觉到你在开发新功能或修复bug的时候",{"2":{"1":1}}],["feature",{"2":{"1":1}}],["quot",{"2":{"1":2}}],["即使代码看起来没什么问题",{"2":{"1":1}}],["会变得越发小心翼翼",{"2":{"1":1}}],["当然了自动化测试不可能保证一个程序是完全正确的",{"2":{"3":1}}],["当然不仅如此",{"2":{"3":1}}],["当测试代码编写完之后",{"2":{"3":1}}],["当你想要对项目中的代码进行重构的时候",{"2":{"1":1}}],["当维护者的数量不止你一个",{"2":{"1":1}}],["当代码的复杂度达到了一定的级别",{"2":{"1":1}}],["对于稍微有一些开发经验的同学在开发过程中总会经历下面类似的问题",{"2":{"1":1}}],["概述",{"0":{"1":1}}]],"serializationVersion":2}';export{t as default};
