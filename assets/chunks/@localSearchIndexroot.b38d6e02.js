const t='{"documentCount":14,"nextId":14,"documentIds":{"0":"/testing/guide/#前端测试基础概念","1":"/testing/guide/#概述","2":"/testing/guide/#手动测试","3":"/testing/guide/#自动化测试","4":"/testing/guide/#测试分类","5":"/testing/guide/#单元测试","6":"/testing/guide/#集成测试","7":"/testing/guide/#端到端测试-e2e","8":"/testing/guide/#快照测试","9":"/testing/guide/#我应该编写哪种测试类型","10":"/testing/guide/#测试覆盖率","11":"/testing/guide/#代码覆盖率","12":"/testing/guide/#需求覆盖率","13":"/testing/guide/#总结"},"fieldIds":{"title":0,"titles":1,"text":2},"fieldLength":{"0":[1,1,1],"1":[1,1,31],"2":[1,1,21],"3":[1,1,48],"4":[1,1,10],"5":[1,1,52],"6":[1,1,18],"7":[3,1,45],"8":[1,1,7],"9":[2,1,106],"10":[1,1,12],"11":[1,2,28],"12":[1,2,34],"13":[1,2,43]},"averageFieldLength":[1.2142857142857142,1.2142857142857142,32.57142857142857],"storedFields":{"0":{"title":"前端测试基础概念","titles":[]},"1":{"title":"概述","titles":["前端测试基础概念"]},"2":{"title":"手动测试","titles":["前端测试基础概念"]},"3":{"title":"自动化测试","titles":["前端测试基础概念"]},"4":{"title":"测试分类","titles":["前端测试基础概念"]},"5":{"title":"单元测试","titles":["前端测试基础概念"]},"6":{"title":"集成测试","titles":["前端测试基础概念"]},"7":{"title":"端到端测试(E2E)","titles":["前端测试基础概念"]},"8":{"title":"快照测试","titles":["前端测试基础概念"]},"9":{"title":"我应该编写哪种测试类型？","titles":["前端测试基础概念"]},"10":{"title":"测试覆盖率","titles":["前端测试基础概念"]},"11":{"title":"代码覆盖率","titles":["前端测试基础概念","测试覆盖率"]},"12":{"title":"需求覆盖率","titles":["前端测试基础概念","测试覆盖率"]},"13":{"title":"总结","titles":["前端测试基础概念","测试覆盖率"]}},"dirtCount":0,"index":[["然而当api确实在生产环境中返回错误时",{"2":{"13":1}}],["假定的是该api永远不会反悔错误",{"2":{"13":1}}],["实现传说中的100",{"2":{"13":1}}],["存在的bug可能会导致数百万美元的损失",{"2":{"13":1}}],["将100",{"2":{"13":1}}],["维护成本太高",{"2":{"13":1}}],["经常做更改的活动页面我认为没必要必须趋近100",{"2":{"13":1}}],["后期再慢慢完善",{"2":{"13":1}}],["既然测试这么好",{"2":{"13":1}}],["才是一条让测试工作越来越好的光明大道",{"2":{"13":1}}],["利用和改进这个数据",{"2":{"13":1}}],["没有覆盖率数据",{"2":{"13":1}}],["没有时间进行测试的编写",{"2":{"3":1}}],["关注测试覆盖率",{"2":{"13":1}}],["100",{"2":{"12":1}}],["1实际使用来看",{"2":{"5":1}}],["都可能是千变万化的",{"2":{"12":1}}],["都写",{"2":{"9":1}}],["因为要不断的更改测试用例",{"2":{"13":1}}],["因为需求可能有遗漏或存在缺陷",{"2":{"12":1}}],["因为代码的执行顺序和函数的参数值",{"2":{"12":1}}],["因此",{"2":{"12":1}}],["因此你可以在每次代码变更后都运行单元测试",{"2":{"5":1}}],["的覆盖率也不能说万事大吉",{"2":{"12":1}}],["的代码覆盖率并不能说明代码就被完全覆盖没有遗漏了",{"2":{"12":1}}],["的测试用例",{"2":{"13":1}}],["的测试",{"2":{"9":1}}],["广为诟病的一点就是100",{"2":{"12":1}}],["例如",{"2":{"12":1}}],["例如功能测试",{"2":{"11":1,"12":1}}],["视需求粒度的不同",{"2":{"12":1}}],["即有意识的去收集这种数据",{"2":{"13":1}}],["即测试所覆盖的需求数量与总需求数量的比值",{"2":{"12":1}}],["即使代码看起来没什么问题",{"2":{"1":1}}],["度量这类测试完整性的手段一般是需求覆盖率",{"2":{"12":1}}],["度量它们的代码覆盖率则相对困难多了",{"2":{"11":1}}],["来说",{"2":{"11":1}}],["系统测试针对的是比较粗的需求",{"2":{"12":1}}],["系统测试等来说",{"2":{"12":1}}],["系统测试",{"2":{"11":1}}],["尤其是用例是否真正能够覆盖对应的测试需求",{"2":{"12":1}}],["尤其是需要依赖人工去标记每个测试用例和需求之间的映射关系",{"2":{"12":1}}],["尤其是单元测试",{"2":{"11":1}}],["尤其是对于前端",{"2":{"6":1}}],["那是不是所有代码都要有测试用例支持呢",{"2":{"13":1}}],["那就是它们一般只适用于白盒测试",{"2":{"11":1}}],["那么100",{"2":{"13":1}}],["那么整个调试过程会变得更加糟糕",{"2":{"7":1}}],["那么测试套件将需要数小时的运行时间",{"2":{"7":1}}],["语句覆盖率等",{"2":{"11":1}}],["分支覆盖率",{"2":{"11":1}}],["类覆盖率",{"2":{"11":1}}],["根据代码粒度的不同",{"2":{"11":1}}],["根据情况灵活分配",{"2":{"9":1}}],["被执行的代码数量与代码总数量之间的比值",{"2":{"11":1}}],["需要注意的是",{"2":{"13":1}}],["需要打开浏览器并逐步完成用户操作以重现bug",{"2":{"7":1}}],["需求覆盖率的具体表现也有不同",{"2":{"12":1}}],["需求覆盖率",{"0":{"12":1},"2":{"10":1}}],["正确了解测试状态",{"2":{"10":1}}],["掌握测试覆盖率数据",{"2":{"10":1}}],["是衡量软件测试完整性的一个重要指标",{"2":{"10":1}}],["是利用计算机程序检查软件是否运行正常的测试方法",{"2":{"3":1}}],["算法写单元测试",{"2":{"9":1}}],["建议写更多的集成测试",{"2":{"9":1}}],["建议写更多的单元测试",{"2":{"9":1}}],["建议写更多的单元测试+少量的集成测试",{"2":{"9":1}}],["写少量的端到端测试",{"2":{"9":1}}],["写少量的集成测试+端到端测试",{"2":{"9":1}}],["写许多模拟真实用户行为的集成测试",{"2":{"9":1}}],["下面是针对不同的应用场景为了一些个人建议",{"2":{"9":1}}],["下一步理所当然就是去手动测试它",{"2":{"2":1}}],["增强应用构建信息",{"2":{"9":1}}],["增强程序员对程序健壮性",{"2":{"3":1}}],["为工具类库",{"2":{"9":1}}],["为每个组件编写快照测试",{"2":{"9":1}}],["为应用核心业务流程编写少量的高层次端到端测试",{"2":{"9":1}}],["为应用中的特定算法或是工具函数编写小而快的单元测试",{"2":{"9":1}}],["为稳定的组件编写快照测试",{"2":{"9":1}}],["为了维持奖杯模型的形状",{"2":{"9":1}}],["使用typescript增强类型定义",{"2":{"9":1}}],["越是下层的测试测试的效率是越高的",{"2":{"9":1}}],["越是上层的测试给开发者带来的自信是越大的",{"2":{"9":1}}],["获取数据库数据等",{"2":{"9":1}}],["获取数据库的数据等依赖第三方环境的行为进行mock",{"2":{"9":1}}],["包括网络请求",{"2":{"9":1}}],["vue",{"2":{"9":1}}],["library等",{"2":{"9":1}}],["library",{"2":{"9":1}}],["react",{"2":{"9":1}}],["模拟用户在真实环境上操作行为",{"2":{"9":1}}],["模拟用户的行为进行测试",{"2":{"9":1}}],["模型示意图如下",{"2":{"9":1}}],["flow",{"2":{"9":1}}],["feature",{"2":{"1":1}}],["代表库",{"2":{"9":4}}],["代码覆盖率不仅耗时",{"2":{"13":1}}],["代码覆盖率对你是有用的",{"2":{"13":1}}],["代码覆盖率作为目标并没有意义",{"2":{"13":1}}],["代码覆盖率可以进一步分为源文件覆盖率",{"2":{"11":1}}],["代码覆盖率",{"0":{"11":1},"2":{"10":1}}],["代码覆盖率较低",{"2":{"6":1}}],["代码覆盖率高",{"2":{"5":1}}],["代码的完工其实并不等于开发的完工",{"2":{"1":1}}],["静态测试",{"2":{"9":1}}],["奖杯模型综合考虑了这两点因素",{"2":{"9":1}}],["奖杯模型中自下而上分为静态测试",{"2":{"9":1}}],["奖杯模型摘自kent",{"2":{"9":1}}],["该模型是笔者比较认可的前端现代化测试模型",{"2":{"9":1}}],["dots提出的the",{"2":{"9":1}}],["其通过率给开发者带来的信心是越大的",{"2":{"9":1}}],["同时需注意的是越是上层的测试",{"2":{"9":1}}],["与此同时",{"2":{"9":1}}],["与之相对",{"2":{"9":1}}],["与端到端测试不同",{"2":{"5":1}}],["之所以是金字塔结构是因为单元测试的成本最低",{"2":{"9":1}}],["之后就很少对该块代码进行管理",{"2":{"3":1}}],["ui测试写的数量最少",{"2":{"9":1}}],["ui测试的成本最高",{"2":{"9":1}}],["ui测试",{"2":{"9":1}}],["金字塔模型自下而上分为单元测试",{"2":{"9":1}}],["with",{"2":{"9":1}}],["webdriverio",{"2":{"7":1}}],["suceeding",{"2":{"9":1}}],["covergage",{"2":{"10":1}}],["cohn在他的著作",{"2":{"9":1}}],["c",{"2":{"9":1}}],["cypress",{"2":{"7":1,"9":1}}],["mike",{"2":{"9":1}}],["mocha+chai+sinon+mockserver+istanbul",{"2":{"5":1}}],["mocha+chai+sinon+mockserver+istanbuljest",{"2":{"5":1}}],["mocha灵活自由",{"2":{"5":1}}],["mocha跟jest是目前最火的两个单元测试框架",{"2":{"5":1}}],["mocha",{"2":{"5":1,"9":1}}],["基于真实浏览器环境测试用户执行它所期望的工作",{"2":{"9":1}}],["基本上目前前端单元测试就在这两个库之间选了",{"2":{"5":1}}],["主要用于ui测试",{"2":{"9":1}}],["得到预期的结果",{"2":{"9":1}}],["给出特定输入",{"2":{"9":1}}],["保证一些方法执行特定的任务",{"2":{"9":1}}],["它关注的是在执行测试用例时",{"2":{"11":1}}],["它们不是互相排斥",{"2":{"13":1}}],["它们适用于不同的场景",{"2":{"13":1}}],["它们的本质是一致的",{"2":{"12":1}}],["它们的职责大致如下",{"2":{"9":1}}],["它们形式各异",{"2":{"11":1}}],["它们是重复性的",{"2":{"2":1}}],["它还告诉你每一层需要写多少测试",{"2":{"9":1}}],["它让你一眼就知道测试是需要分层的",{"2":{"9":1}}],["它是从程序员的角度编写的",{"2":{"9":1}}],["组件",{"2":{"9":1}}],["组件也是被测单元",{"2":{"5":1}}],["函数覆盖率",{"2":{"11":1}}],["函数",{"2":{"9":1}}],["对于需求覆盖率来说",{"2":{"12":1}}],["对于代码覆盖率来说",{"2":{"12":1}}],["对于黑盒测试",{"2":{"11":1,"12":1}}],["对于稍微有一些开发经验的同学在开发过程中总会经历下面类似的问题",{"2":{"1":1}}],["对网络请求",{"2":{"9":1}}],["对应用中多个模块组织到一起的正确性进行测试",{"2":{"9":1}}],["对应用程序最小的部分",{"2":{"9":1}}],["我建议前期先做最短的时间覆盖80",{"2":{"13":1}}],["我认为测试覆盖率还是要和测试成本结合起来",{"2":{"13":1}}],["我到底该写哪种测试",{"2":{"9":1}}],["我应该编写哪种测试类型",{"0":{"9":1}}],["我们如何从一开始就整合不同的测试技巧",{"2":{"3":1}}],["则测试失败",{"2":{"8":1}}],["并持续检测",{"2":{"13":1}}],["并将其与以前保存的图片进行比较",{"2":{"8":1}}],["并且你想测试两个数求和的运算方法是否正确",{"2":{"7":1}}],["最重要的一点应该是迈出第一步",{"2":{"13":1}}],["最著名的测试覆盖率就是代码覆盖率",{"2":{"11":1}}],["最流行的是cypress",{"2":{"7":1}}],["最后检查屏幕是否显示正确结果2",{"2":{"7":1}}],["playwright",{"2":{"7":1}}],["nightwatch",{"2":{"7":1}}],["本地运行这个调试过程就已经够糟糕了",{"2":{"7":1}}],["要调试端到端测试",{"2":{"7":1}}],["要求投入更多注意力",{"2":{"2":1}}],["网站响应速度又慢",{"2":{"7":1}}],["启动浏览器需要占用几秒钟",{"2":{"7":1}}],["首先",{"2":{"7":1}}],["更容易获得程序的信息",{"2":{"7":1}}],["更容易获得软件使用过程中的正确性",{"2":{"6":1}}],["真实的测试环境",{"2":{"7":1}}],["再次单击1按钮",{"2":{"7":1}}],["单击等号=",{"2":{"7":1}}],["单击加号+按钮",{"2":{"7":1}}],["单击1按钮",{"2":{"7":1}}],["单元",{"2":{"5":1}}],["单元测试的职责是对一些边界情况或者特定的算法进行测试",{"2":{"9":1}}],["单元测试的缺点",{"2":{"5":1}}],["单元测试的优点",{"2":{"5":1}}],["单元测试应该避免依赖性问题",{"2":{"5":1}}],["单元测试运行速度很快",{"2":{"5":1}}],["单元测试可以单独调用源代码中的函数并断言其行为是否正确",{"2":{"5":1}}],["单元测试是对应用程序最小的部分",{"2":{"5":1}}],["单元测试",{"0":{"5":1},"2":{"4":1,"9":3}}],["加载计算器应用程序",{"2":{"7":1}}],["打开浏览器",{"2":{"7":1}}],["想象一下",{"2":{"7":2}}],["eslint",{"2":{"9":1}}],["end",{"2":{"7":2}}],["e2e测试",{"2":{"9":2}}],["e2e",{"0":{"7":1},"2":{"7":1}}],["速度比单元测试要慢",{"2":{"6":1}}],["缺点",{"2":{"6":1,"7":1}}],["相比执行数百次同样的手动测试",{"2":{"7":1}}],["相比单元测试",{"2":{"6":1}}],["相比手动测试而言节省了大量时间以及提高了程序的稳定性",{"2":{"3":1}}],["由于不关注底层代码实现细节",{"2":{"6":1}}],["由于是从用户使用角度出发",{"2":{"6":1}}],["由于单元测试是独立的",{"2":{"5":1}}],["优点",{"2":{"6":1,"7":1}}],["也可能是存在疑问的",{"2":{"12":1}}],["也可以直接对比程序渲染之后的截图",{"2":{"3":1}}],["也有些人认为任何完全渲染的组件测试都是集成测试",{"2":{"6":1}}],["有时你可能还会做出错误的假设",{"2":{"13":1}}],["有了覆盖率数据",{"2":{"13":1}}],["有各自的优势与不足",{"2":{"13":1}}],["有哪些软件代码没有被执行到",{"2":{"11":1}}],["有哪些软件代码被执行到了",{"2":{"11":1}}],["有效改进测试工作",{"2":{"10":1}}],["有利于客观认识软件质量",{"2":{"10":1}}],["有些人认为对具有模块依赖性的单元进行的任何测试都是集成测试",{"2":{"6":1}}],["有些人认为在浏览器环境上运行的测试是集成测试",{"2":{"6":1}}],["有助于代码的模块化设计",{"2":{"5":1}}],["人们定义集成测试的方式并不相同",{"2":{"6":1}}],["推荐使用",{"2":{"5":1}}],["目前最火的是jest",{"2":{"5":1}}],["===",{"2":{"5":2}}],["两者功能覆盖范围粗略可以表示为",{"2":{"5":1}}],["自由配置",{"2":{"5":1}}],["自动化测试还有很多优点",{"2":{"3":1}}],["自动化测试",{"0":{"3":1},"2":{"1":1,"3":1}}],["配置方便",{"2":{"5":1}}],["总结",{"0":{"13":1}}],["总的来说就是jest功能齐全",{"2":{"5":1}}],["总之",{"2":{"2":1}}],["test",{"2":{"10":1}}],["testing",{"2":{"3":1,"9":3}}],["typescript",{"2":{"9":1}}],["trophy",{"2":{"9":1}}],["to",{"2":{"7":1}}],["tape",{"2":{"5":1}}],["agile",{"2":{"9":1}}],["ava",{"2":{"5":1}}],["automated",{"2":{"3":1}}],["karma",{"2":{"5":1}}],["jsjest",{"2":{"5":1}}],["jasmine",{"2":{"5":1}}],["jest",{"2":{"5":1,"9":2}}],["常见的javascript单元测试",{"2":{"5":1}}],["让代码维护更容易",{"2":{"5":1}}],["减少bug",{"2":{"5":1}}],["减少调试时间",{"2":{"3":1,"5":1}}],["提升代码质量",{"2":{"5":1}}],["而对于一个完整项目",{"2":{"13":1}}],["而是相互补充的",{"2":{"13":1}}],["而是使用工具虚拟出运行环境",{"2":{"5":1}}],["而需求依赖人工计算",{"2":{"12":1}}],["而功能测试针对的是比较细的需求",{"2":{"12":1}}],["而且即使代码覆盖率达到100",{"2":{"13":1}}],["而且一旦掌握了前端自动化测试方案无论是对应对大型项目的开发还是升职加薪都是有益的",{"2":{"3":1}}],["而且事实上",{"2":{"3":1}}],["而且没有创造性的输入",{"2":{"2":1}}],["不代表所有情况被覆盖到",{"2":{"12":1}}],["不用花大力气搭建各种测试环境",{"2":{"5":1}}],["不访问网络等等",{"2":{"5":1}}],["不能保证代码能够正常运行",{"2":{"1":1}}],["从用户角度出发",{"2":{"9":1}}],["从用户角度以机器的方式在真实浏览器环境验证应用交互",{"2":{"4":1}}],["从程序角度出发",{"2":{"9":1}}],["从而快速得到变更是否破坏现有功能的反馈",{"2":{"5":1}}],["只需要几秒钟的运行时间",{"2":{"5":1}}],["只是打开浏览器手动点击",{"2":{"3":1}}],["测试也并非总能发现bug",{"2":{"13":1}}],["测试工作会有点像在黑灯瞎火中走路",{"2":{"13":1}}],["测试用例与需求之间的映射关系",{"2":{"12":1}}],["测试用例通常是基于软件需求而不是软件实现所设计的",{"2":{"12":1}}],["测试覆盖率",{"0":{"10":1},"1":{"11":1,"12":1,"13":1},"2":{"10":1}}],["测试金字塔",{"2":{"9":1}}],["测试失败的时候无法快速定位问题",{"2":{"6":1}}],["测试的单元是函数",{"2":{"5":1}}],["测试分类",{"0":{"4":1}}],["通常没有现成的工具可以使用",{"2":{"12":1}}],["通常一套端到端测试需要30分钟的运行时间",{"2":{"7":1}}],["通常",{"2":{"5":1}}],["通过测试人员与应用程序的交互来检查是否正常工作",{"2":{"1":1}}],["运行测试的过程",{"2":{"5":1,"9":1}}],["快速",{"2":{"9":1}}],["快速反馈",{"2":{"3":1,"5":1}}],["快照测试会给运行中的应用程序拍一张图片",{"2":{"8":1}}],["快照测试类似于找不同游戏",{"2":{"8":1,"9":1}}],["快照测试",{"0":{"8":1},"2":{"4":1,"9":1}}],["端到端测试是从用户的角度编写的",{"2":{"9":1}}],["端到端测试是最直观可以理解的测试类型",{"2":{"7":1}}],["端到端测试的另一个问题是调试起来比较困难",{"2":{"7":1}}],["端到端测试运行不够快",{"2":{"7":1}}],["端到端测试可以从用户的视角通过浏览器自动检查应用程序是否正常工作",{"2":{"7":1}}],["端到端测试",{"0":{"7":1},"2":{"4":1,"9":1}}],["验证程序的ui变化",{"2":{"4":1}}],["验证多个单元协同工作",{"2":{"4":1}}],["验证独立的单元是否正常工作",{"2":{"4":1}}],["集成测试的开发速度要更快一些",{"2":{"6":1}}],["集成测试相对于写了软件的说明文档",{"2":{"6":1}}],["集成测试",{"0":{"6":1},"2":{"4":1,"9":4,"12":1}}],["编制一个高效的测试套件",{"2":{"3":1}}],["编写完一个端到端测试后",{"2":{"7":1}}],["编写自动化测试代码通常是开发人员不太喜欢的一个环节",{"2":{"3":1}}],["编写应用程序来替代人工检验",{"2":{"1":1}}],["一种情况呗覆盖到",{"2":{"12":1}}],["一般可以通过第三方工具完成",{"2":{"11":1}}],["一书中提出了这个概念",{"2":{"9":1}}],["一些流行的端到端测试框架",{"2":{"7":1}}],["一些特殊场景下的测试问题该怎么解决",{"2":{"3":1}}],["一个健康",{"2":{"9":1}}],["一个是业务繁忙",{"2":{"3":1}}],["一个简单的定义是",{"2":{"1":1}}],["应用程序中哪些部分应该被优先测试",{"2":{"3":1}}],["应用程序测试是指检查程序运行过程是否正确",{"2":{"1":1}}],["所以单元测试写的数量最多",{"2":{"9":1}}],["所以更有利于快速重构",{"2":{"6":1}}],["所以无法保证多个单元运行到一起是否正确",{"2":{"5":1}}],["所以",{"2":{"3":1}}],["另一个是不知道如何编写测试",{"2":{"3":1}}],["造成这个情况的原因主要有两个",{"2":{"3":1}}],["查看效果是否正确",{"2":{"3":1}}],["前端开发最常见的测试主要是以下几种",{"2":{"4":1}}],["前端开发人员在开发完一项功能后",{"2":{"3":1}}],["前端测试基础概念",{"0":{"0":1},"1":{"1":1,"2":1,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"9":1,"10":1,"11":1,"12":1,"13":1}}],["大多数情况下",{"2":{"3":1,"13":1}}],["大部分时间都在做回归测试",{"2":{"2":1}}],["促进重构",{"2":{"3":1}}],["改进设计",{"2":{"3":1}}],["稳定性的信心",{"2":{"3":1}}],["今早的发现程序的bug和不足",{"2":{"3":1}}],["比如一个不会经常变的公共方法就尽可能的将测试覆盖率做到趋于100",{"2":{"13":1}}],["比如jest自带了测试覆盖率统计",{"2":{"11":1}}],["比如使用eslint约束代码规范",{"2":{"9":1}}],["比如不存取数据库",{"2":{"5":1}}],["比如",{"2":{"3":1}}],["虽然每一种方法的优势各不相同",{"2":{"3":1}}],["虽然有一部分手动测试时间是花在测试新特性上",{"2":{"2":1}}],["可维护的测试组合应该是这样的",{"2":{"9":1}}],["可以看到其在集成测试中的占比是最高的",{"2":{"9":1}}],["可以根据自己的需求随时运行它",{"2":{"7":1}}],["可以直接调用源代码里的函数",{"2":{"3":1}}],["可以编写浏览器自动执行的程序",{"2":{"3":1}}],["可使用许多种不同的方法来编写自动化测试脚本",{"2":{"3":1}}],["就是代码覆盖率",{"2":{"11":1}}],["就是用其他额外的代码检查被测软件的代码",{"2":{"3":1}}],["就可以不费吹灰之力的进行无数次重复测试",{"2":{"3":1}}],["换句话说",{"2":{"3":1}}],["计算机特别擅长此类工作",{"2":{"2":1}}],["幸运的是",{"2":{"2":1}}],["回归测试对人类来说是非常困难的任务",{"2":{"2":1}}],["这些度量工具有个特点",{"2":{"11":1}}],["这些部分应该使用什么方法进行测试",{"2":{"3":1}}],["这里",{"2":{"11":1}}],["这是一种面向软件开发和实现的定义",{"2":{"11":1}}],["这样一套测试代码可以节省多少时间",{"2":{"7":1}}],["这种虚拟使得测试成本最小化",{"2":{"5":1}}],["这种测试方法对确保应用程序代码变更后是否仍然可以正确渲染很有帮助",{"2":{"8":1}}],["这种测试太枯燥了",{"2":{"2":1}}],["这种测试被称为回归测试",{"2":{"2":1}}],["这也是自动化测试可以大展身手的地方",{"2":{"2":1}}],["这个比喻非常形象",{"2":{"9":1}}],["这个fix会不会引入其他",{"2":{"1":1}}],["这个feature会不会带来其他bug",{"2":{"1":1}}],["这个过程非常枯燥而痛苦",{"2":{"1":1}}],["忘记测试某项功能",{"2":{"2":1}}],["手动不适合大型项目",{"2":{"2":1}}],["手动测试的优势在于足够简单灵活",{"2":{"2":1}}],["手动测试",{"0":{"2":1},"2":{"1":1}}],["但本质是相同",{"2":{"11":1}}],["但在前端应用中",{"2":{"5":1}}],["但这些问题不应该作为我们掌握前端自动化测试的绊脚石",{"2":{"3":1}}],["但它们有一大共同点",{"2":{"3":1}}],["但是大部分时间还是用来检查之前的特性是否仍正常工作",{"2":{"2":1}}],["但是缺点也很明显",{"2":{"2":1}}],["但你心里还是会犯嘀咕",{"2":{"1":1}}],["每一个称职的开发人员都懂得手动测试代码",{"2":{"2":1}}],["每次在版本发布上线之前",{"2":{"1":1}}],["如何度量需求覆盖率呢",{"2":{"12":1}}],["如何度量代码覆盖率呢",{"2":{"11":1}}],["如何度量测试覆盖率呢",{"2":{"10":1}}],["如何进行前端应用测试",{"2":{"3":1}}],["如何进行应用程序测试",{"2":{"1":1}}],["如果你在开发一个极其重要的支付应用",{"2":{"13":1}}],["如果你是开发业务系统",{"2":{"9":1}}],["如果你是开发组件库",{"2":{"9":1}}],["如果你是开发纯函数库",{"2":{"9":1}}],["如果你真的想为你的软件构建自动化测试",{"2":{"9":1}}],["如果图像不同",{"2":{"8":1}}],["如果测试是在持续集成服务器上失败而不是本地计算机上失败",{"2":{"7":1}}],["如果应用程序完全依赖于端到端测试",{"2":{"7":1}}],["如果没有测试",{"2":{"1":1}}],["在底层为应用配置静态测试",{"2":{"9":1}}],["在奖杯模型中",{"2":{"9":1}}],["在编写代码逻辑阶段时进行报错提示",{"2":{"9":1}}],["在编写完源代码之后",{"2":{"2":1}}],["在前端应用程序中",{"2":{"7":1}}],["在实际开发过程中",{"2":{"3":1}}],["在日常的开发中",{"2":{"1":1}}],["在电脑前蹲上好几个小时甚至是更长时间对你的应用进行测试",{"2":{"1":1}}],["什么是应用程序测试",{"2":{"1":1}}],["解决它的根本原因就在于引入自动化测试方案",{"2":{"1":1}}],["以上这些问题都是由于大多数开发者所使用最基本的手动测试的方式所带来的问题",{"2":{"1":1}}],["你的应用就崩溃了",{"2":{"13":1}}],["你必须知道一个关键的概念",{"2":{"9":1}}],["你可以编写一个端到端测试",{"2":{"7":1}}],["你正在编写一个计算机应用程序",{"2":{"7":1}}],["你会花费大量的时间进行回归测试",{"2":{"1":1}}],["你应该会逐渐察觉到你在开发新功能或修复bug的时候",{"2":{"1":1}}],["quot",{"2":{"1":2}}],["会变得越发小心翼翼",{"2":{"1":1}}],["当你调用一个api代码时",{"2":{"13":1}}],["当你想要对项目中的代码进行重构的时候",{"2":{"1":1}}],["当然",{"2":{"12":1,"13":1}}],["当然了自动化测试不可能保证一个程序是完全正确的",{"2":{"3":1}}],["当然不仅如此",{"2":{"3":1}}],["当测试代码编写完之后",{"2":{"3":1}}],["当维护者的数量不止你一个",{"2":{"1":1}}],["当代码的复杂度达到了一定的级别",{"2":{"1":1}}],["概述",{"0":{"1":1}}]],"serializationVersion":2}';export{t as default};
