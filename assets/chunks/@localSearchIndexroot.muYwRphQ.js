const t='{"documentCount":17,"nextId":17,"documentIds":{"0":"/testing/guide/develop-method.html#测试开发方式","1":"/testing/guide/develop-method.html#tdd","2":"/testing/guide/develop-method.html#tdd的原则","3":"/testing/guide/#前端测试基础概念","4":"/testing/guide/#概述","5":"/testing/guide/#手动测试","6":"/testing/guide/#自动化测试","7":"/testing/guide/#测试分类","8":"/testing/guide/#单元测试","9":"/testing/guide/#集成测试","10":"/testing/guide/#端到端测试-e2e","11":"/testing/guide/#快照测试","12":"/testing/guide/#我应该编写哪种测试类型","13":"/testing/guide/#测试覆盖率","14":"/testing/guide/#代码覆盖率","15":"/testing/guide/#需求覆盖率","16":"/testing/guide/#总结"},"fieldIds":{"title":0,"titles":1,"text":2},"fieldLength":{"0":[1,1,11],"1":[1,1,21],"2":[1,2,89],"3":[1,1,1],"4":[1,1,31],"5":[1,1,21],"6":[1,1,48],"7":[1,1,10],"8":[1,1,51],"9":[1,1,18],"10":[3,1,45],"11":[1,1,7],"12":[2,1,106],"13":[1,1,12],"14":[1,2,28],"15":[1,2,34],"16":[1,2,43]},"averageFieldLength":[1.1764705882352942,1.2352941176470589,33.88235294117648],"storedFields":{"0":{"title":"测试开发方式","titles":[]},"1":{"title":"TDD","titles":["测试开发方式"]},"2":{"title":"TDD的原则","titles":["测试开发方式","TDD"]},"3":{"title":"前端测试基础概念","titles":[]},"4":{"title":"概述","titles":["前端测试基础概念"]},"5":{"title":"手动测试","titles":["前端测试基础概念"]},"6":{"title":"自动化测试","titles":["前端测试基础概念"]},"7":{"title":"测试分类","titles":["前端测试基础概念"]},"8":{"title":"单元测试","titles":["前端测试基础概念"]},"9":{"title":"集成测试","titles":["前端测试基础概念"]},"10":{"title":"端到端测试(E2E)","titles":["前端测试基础概念"]},"11":{"title":"快照测试","titles":["前端测试基础概念"]},"12":{"title":"我应该编写哪种测试类型？","titles":["前端测试基础概念"]},"13":{"title":"测试覆盖率","titles":["前端测试基础概念"]},"14":{"title":"代码覆盖率","titles":["前端测试基础概念","测试覆盖率"]},"15":{"title":"需求覆盖率","titles":["前端测试基础概念","测试覆盖率"]},"16":{"title":"总结","titles":["前端测试基础概念","测试覆盖率"]}},"dirtCount":0,"index":[["然而当api确实在生产环境中返回错误时",{"2":{"16":1}}],["然后编写必要的辅助语句",{"2":{"2":1}}],["然后在对其进行设计",{"2":{"2":1}}],["然后才能继续手头工作",{"2":{"2":1}}],["假定的是该api永远不会反悔错误",{"2":{"16":1}}],["实现传说中的100",{"2":{"16":1}}],["存在的bug可能会导致数百万美元的损失",{"2":{"16":1}}],["将100",{"2":{"16":1}}],["维护成本太高",{"2":{"16":1}}],["经常做更改的活动页面我认为没必要必须趋近100",{"2":{"16":1}}],["后期再慢慢完善",{"2":{"16":1}}],["既然测试这么好",{"2":{"16":1}}],["才是一条让测试工作越来越好的光明大道",{"2":{"16":1}}],["利用和改进这个数据",{"2":{"16":1}}],["没有覆盖率数据",{"2":{"16":1}}],["没有时间进行测试的编写",{"2":{"6":1}}],["关注测试覆盖率",{"2":{"16":1}}],["关注点过于独立",{"2":{"2":1}}],["100",{"2":{"15":1}}],["1实际使用来看",{"2":{"8":1}}],["都可能是千变万化的",{"2":{"15":1}}],["都写",{"2":{"12":1}}],["的覆盖率也不能说万事大吉",{"2":{"15":1}}],["的代码覆盖率并不能说明代码就被完全覆盖没有遗漏了",{"2":{"15":1}}],["的测试用例",{"2":{"16":1}}],["的测试",{"2":{"12":1}}],["广为诟病的一点就是100",{"2":{"15":1}}],["例如",{"2":{"15":1}}],["例如功能测试",{"2":{"14":1,"15":1}}],["视需求粒度的不同",{"2":{"15":1}}],["度量这类测试完整性的手段一般是需求覆盖率",{"2":{"15":1}}],["度量它们的代码覆盖率则相对困难多了",{"2":{"14":1}}],["来说",{"2":{"14":1}}],["系统测试针对的是比较粗的需求",{"2":{"15":1}}],["系统测试等来说",{"2":{"15":1}}],["系统测试",{"2":{"14":1}}],["那是不是所有代码都要有测试用例支持呢",{"2":{"16":1}}],["那就是它们一般只适用于白盒测试",{"2":{"14":1}}],["那么100",{"2":{"16":1}}],["那么整个调试过程会变得更加糟糕",{"2":{"10":1}}],["那么测试套件将需要数小时的运行时间",{"2":{"10":1}}],["语句覆盖率等",{"2":{"14":1}}],["分支覆盖率",{"2":{"14":1}}],["类覆盖率",{"2":{"14":1}}],["根据代码粒度的不同",{"2":{"14":1}}],["根据情况灵活分配",{"2":{"12":1}}],["被执行的代码数量与代码总数量之间的比值",{"2":{"14":1}}],["需要注意的是",{"2":{"16":1}}],["需要打开浏览器并逐步完成用户操作以重现bug",{"2":{"10":1}}],["需求覆盖率的具体表现也有不同",{"2":{"15":1}}],["需求覆盖率",{"0":{"15":1},"2":{"13":1}}],["正确了解测试状态",{"2":{"13":1}}],["掌握测试覆盖率数据",{"2":{"13":1}}],["算法写单元测试",{"2":{"12":1}}],["建议写更多的集成测试",{"2":{"12":1}}],["建议写更多的单元测试",{"2":{"12":1}}],["建议写更多的单元测试+少量的集成测试",{"2":{"12":1}}],["写少量的端到端测试",{"2":{"12":1}}],["写少量的集成测试+端到端测试",{"2":{"12":1}}],["写许多模拟真实用户行为的集成测试",{"2":{"12":1}}],["下面是针对不同的应用场景为了一些个人建议",{"2":{"12":1}}],["下一步理所当然就是去手动测试它",{"2":{"5":1}}],["增强应用构建信息",{"2":{"12":1}}],["增强程序员对程序健壮性",{"2":{"6":1}}],["为工具类库",{"2":{"12":1}}],["为每个组件编写快照测试",{"2":{"12":1}}],["为应用核心业务流程编写少量的高层次端到端测试",{"2":{"12":1}}],["为应用中的特定算法或是工具函数编写小而快的单元测试",{"2":{"12":1}}],["为稳定的组件编写快照测试",{"2":{"12":1}}],["为了维持奖杯模型的形状",{"2":{"12":1}}],["使用typescript增强类型定义",{"2":{"12":1}}],["越是下层的测试测试的效率是越高的",{"2":{"12":1}}],["越是上层的测试给开发者带来的自信是越大的",{"2":{"12":1}}],["获取数据库数据等",{"2":{"12":1}}],["获取数据库的数据等依赖第三方环境的行为进行mock",{"2":{"12":1}}],["包括网络请求",{"2":{"12":1}}],["library等",{"2":{"12":1}}],["library",{"2":{"12":1}}],["react",{"2":{"12":1}}],["react等",{"2":{"2":1}}],["模拟用户在真实环境上操作行为",{"2":{"12":1}}],["模拟用户的行为进行测试",{"2":{"12":1}}],["模型示意图如下",{"2":{"12":1}}],["flow",{"2":{"12":1}}],["feature",{"2":{"4":1}}],["代表库",{"2":{"12":4}}],["代码覆盖率不仅耗时",{"2":{"16":1}}],["代码覆盖率对你是有用的",{"2":{"16":1}}],["代码覆盖率作为目标并没有意义",{"2":{"16":1}}],["代码覆盖率可以进一步分为源文件覆盖率",{"2":{"14":1}}],["代码覆盖率",{"0":{"14":1},"2":{"13":1}}],["代码覆盖率较低",{"2":{"9":1}}],["代码覆盖率高",{"2":{"8":1}}],["代码的完工其实并不等于开发的完工",{"2":{"4":1}}],["代码的功能点可能很多",{"2":{"2":1}}],["代码量增加",{"2":{"2":1}}],["代码重构等",{"2":{"2":1}}],["静态测试",{"2":{"12":1}}],["奖杯模型综合考虑了这两点因素",{"2":{"12":1}}],["奖杯模型中自下而上分为静态测试",{"2":{"12":1}}],["奖杯模型摘自kent",{"2":{"12":1}}],["该模型是笔者比较认可的前端现代化测试模型",{"2":{"12":1}}],["其通过率给开发者带来的信心是越大的",{"2":{"12":1}}],["同时需注意的是越是上层的测试",{"2":{"12":1}}],["与此同时",{"2":{"12":1}}],["与之相对",{"2":{"12":1}}],["与端到端测试不同",{"2":{"8":1}}],["之所以是金字塔结构是因为单元测试的成本最低",{"2":{"12":1}}],["之后就很少对该块代码进行管理",{"2":{"6":1}}],["ui测试写的数量最少",{"2":{"12":1}}],["ui测试的成本最高",{"2":{"12":1}}],["ui测试",{"2":{"12":1}}],["金字塔模型自下而上分为单元测试",{"2":{"12":1}}],["with",{"2":{"12":1}}],["webdriverio",{"2":{"10":1}}],["suceeding",{"2":{"12":1}}],["covergage",{"2":{"13":1}}],["cohn在他的著作",{"2":{"12":1}}],["c",{"2":{"12":1}}],["cypress",{"2":{"10":1,"12":1}}],["mike",{"2":{"12":1}}],["mocha+chai+sinon+mockserver+istanbul",{"2":{"8":1}}],["mocha灵活自由",{"2":{"8":1}}],["mocha跟jest是目前最火的两个单元测试框架",{"2":{"8":1}}],["mocha",{"2":{"8":1,"12":1}}],["基于真实浏览器环境测试用户执行它所期望的工作",{"2":{"12":1}}],["基本上目前前端单元测试就在这两个库之间选了",{"2":{"8":1}}],["主要用于ui测试",{"2":{"12":1}}],["得到预期的结果",{"2":{"12":1}}],["给出特定输入",{"2":{"12":1}}],["保证一些方法执行特定的任务",{"2":{"12":1}}],["保证代码质量",{"2":{"0":1,"2":1}}],["组件",{"2":{"12":1}}],["组件也是被测单元",{"2":{"8":1}}],["函数覆盖率",{"2":{"14":1}}],["函数",{"2":{"12":1}}],["我建议前期先做最短的时间覆盖80",{"2":{"16":1}}],["我认为测试覆盖率还是要和测试成本结合起来",{"2":{"16":1}}],["我到底该写哪种测试",{"2":{"12":1}}],["我应该编写哪种测试类型",{"0":{"12":1}}],["我们如何从一开始就整合不同的测试技巧",{"2":{"6":1}}],["则测试失败",{"2":{"11":1}}],["则一个文件对应一个测试文件",{"2":{"2":1}}],["并持续检测",{"2":{"16":1}}],["并将其与以前保存的图片进行比较",{"2":{"11":1}}],["并且你想测试两个数求和的运算方法是否正确",{"2":{"10":1}}],["并且需求可能是陆续出现的",{"2":{"2":1}}],["最重要的一点应该是迈出第一步",{"2":{"16":1}}],["最著名的测试覆盖率就是代码覆盖率",{"2":{"14":1}}],["最流行的是cypress",{"2":{"10":1}}],["最后检查屏幕是否显示正确结果2",{"2":{"10":1}}],["playwright",{"2":{"10":1}}],["nightwatch",{"2":{"10":1}}],["本地运行这个调试过程就已经够糟糕了",{"2":{"10":1}}],["网站响应速度又慢",{"2":{"10":1}}],["启动浏览器需要占用几秒钟",{"2":{"10":1}}],["首先",{"2":{"10":1}}],["更容易获得程序的信息",{"2":{"10":1}}],["更容易获得软件使用过程中的正确性",{"2":{"9":1}}],["真实的测试环境",{"2":{"10":1}}],["再次单击1按钮",{"2":{"10":1}}],["单击等号=",{"2":{"10":1}}],["单击加号+按钮",{"2":{"10":1}}],["单击1按钮",{"2":{"10":1}}],["单元",{"2":{"8":1}}],["单元测试的职责是对一些边界情况或者特定的算法进行测试",{"2":{"12":1}}],["单元测试的缺点",{"2":{"8":1}}],["单元测试的优点",{"2":{"8":1}}],["单元测试应该避免依赖性问题",{"2":{"8":1}}],["单元测试运行速度很快",{"2":{"8":1}}],["单元测试可以单独调用源代码中的函数并断言其行为是否正确",{"2":{"8":1}}],["单元测试是对应用程序最小的部分",{"2":{"8":1}}],["单元测试",{"0":{"8":1},"2":{"7":1,"12":3}}],["加载计算器应用程序",{"2":{"10":1}}],["打开浏览器",{"2":{"10":1}}],["想象一下",{"2":{"10":2}}],["eslint",{"2":{"12":1}}],["end",{"2":{"10":2}}],["e2e测试",{"2":{"12":2}}],["e2e",{"0":{"10":1},"2":{"10":1}}],["速度比单元测试要慢",{"2":{"9":1}}],["缺点",{"2":{"9":1,"10":1}}],["相比执行数百次同样的手动测试",{"2":{"10":1}}],["相比单元测试",{"2":{"9":1}}],["相比手动测试而言节省了大量时间以及提高了程序的稳定性",{"2":{"6":1}}],["优点",{"2":{"9":1,"10":1}}],["优化代码",{"2":{"1":1}}],["尤其是用例是否真正能够覆盖对应的测试需求",{"2":{"15":1}}],["尤其是需要依赖人工去标记每个测试用例和需求之间的映射关系",{"2":{"15":1}}],["尤其是单元测试",{"2":{"14":1}}],["尤其是对于前端",{"2":{"9":1}}],["尤其是增加新功能时",{"2":{"2":1}}],["人们定义集成测试的方式并不相同",{"2":{"9":1}}],["推荐使用",{"2":{"8":1}}],["目前最火的是jest",{"2":{"8":1}}],["===",{"2":{"8":1}}],["两者功能覆盖范围粗略可以表示为",{"2":{"8":1}}],["自由配置",{"2":{"8":1}}],["自动化测试还有很多优点",{"2":{"6":1}}],["自动化测试",{"0":{"6":1},"2":{"4":1,"6":1}}],["配置方便",{"2":{"8":1}}],["总结",{"0":{"16":1}}],["总的来说就是jest功能齐全",{"2":{"8":1}}],["总之",{"2":{"5":1}}],["agile",{"2":{"12":1}}],["ava",{"2":{"8":1}}],["automated",{"2":{"6":1}}],["karma",{"2":{"8":1}}],["jsjest",{"2":{"8":1}}],["jasmine",{"2":{"8":1}}],["jest",{"2":{"8":1,"12":2}}],["常见的javascript单元测试",{"2":{"8":1}}],["有时你可能还会做出错误的假设",{"2":{"16":1}}],["有了覆盖率数据",{"2":{"16":1}}],["有各自的优势与不足",{"2":{"16":1}}],["有哪些软件代码没有被执行到",{"2":{"14":1}}],["有哪些软件代码被执行到了",{"2":{"14":1}}],["有效改进测试工作",{"2":{"13":1}}],["有利于客观认识软件质量",{"2":{"13":1}}],["有利于程序的模块设计",{"2":{"2":1}}],["有些人认为对具有模块依赖性的单元进行的任何测试都是集成测试",{"2":{"9":1}}],["有些人认为在浏览器环境上运行的测试是集成测试",{"2":{"9":1}}],["有助于代码的模块化设计",{"2":{"8":1}}],["让代码维护更容易",{"2":{"8":1}}],["减少bug",{"2":{"8":1}}],["减少调试时间",{"2":{"6":1,"8":1}}],["提升代码质量",{"2":{"8":1}}],["而对于一个完整项目",{"2":{"16":1}}],["而是相互补充的",{"2":{"16":1}}],["而是使用工具虚拟出运行环境",{"2":{"8":1}}],["而需求依赖人工计算",{"2":{"15":1}}],["而功能测试针对的是比较细的需求",{"2":{"15":1}}],["而且即使代码覆盖率达到100",{"2":{"16":1}}],["而且一旦掌握了前端自动化测试方案无论是对应对大型项目的开发还是升职加薪都是有益的",{"2":{"6":1}}],["而且事实上",{"2":{"6":1}}],["而且没有创造性的输入",{"2":{"5":1}}],["而且tdd更多的需要编写独立的测试用例",{"2":{"1":1}}],["从用户角度出发",{"2":{"12":1}}],["从用户角度以机器的方式在真实浏览器环境验证应用交互",{"2":{"7":1}}],["从程序角度出发",{"2":{"12":1}}],["从而快速得到变更是否破坏现有功能的反馈",{"2":{"8":1}}],["只需要几秒钟的运行时间",{"2":{"8":1}}],["只是打开浏览器手动点击",{"2":{"6":1}}],["通常没有现成的工具可以使用",{"2":{"15":1}}],["通常一套端到端测试需要30分钟的运行时间",{"2":{"10":1}}],["通常",{"2":{"8":1}}],["通过测试人员与应用程序的交互来检查是否正常工作",{"2":{"4":1}}],["快速",{"2":{"12":1}}],["快速反馈",{"2":{"6":1,"8":1}}],["快照测试会给运行中的应用程序拍一张图片",{"2":{"11":1}}],["快照测试类似于找不同游戏",{"2":{"11":1,"12":1}}],["快照测试",{"0":{"11":1},"2":{"7":1,"12":1}}],["端到端测试是从用户的角度编写的",{"2":{"12":1}}],["端到端测试是最直观可以理解的测试类型",{"2":{"10":1}}],["端到端测试的另一个问题是调试起来比较困难",{"2":{"10":1}}],["端到端测试运行不够快",{"2":{"10":1}}],["端到端测试可以从用户的视角通过浏览器自动检查应用程序是否正常工作",{"2":{"10":1}}],["端到端测试",{"0":{"10":1},"2":{"7":1,"12":1}}],["验证程序的ui变化",{"2":{"7":1}}],["验证多个单元协同工作",{"2":{"7":1}}],["验证独立的单元是否正常工作",{"2":{"7":1}}],["一种情况呗覆盖到",{"2":{"15":1}}],["一般可以通过第三方工具完成",{"2":{"14":1}}],["一书中提出了这个概念",{"2":{"12":1}}],["一些流行的端到端测试框架",{"2":{"10":1}}],["一些特殊场景下的测试问题该怎么解决",{"2":{"6":1}}],["一个健康",{"2":{"12":1}}],["一个是业务繁忙",{"2":{"6":1}}],["一个简单的定义是",{"2":{"4":1}}],["一个角色",{"2":{"2":1}}],["一个函数对应一个测试函数",{"2":{"2":1}}],["一个类对应一个测试类",{"2":{"2":1}}],["所以单元测试写的数量最多",{"2":{"12":1}}],["所以更有利于快速重构",{"2":{"9":1}}],["所以无法保证多个单元运行到一起是否正确",{"2":{"8":1}}],["所以",{"2":{"6":1}}],["所以可能出现的问题都被提前发现了",{"2":{"2":1}}],["另一个是不知道如何编写测试",{"2":{"6":1}}],["造成这个情况的原因主要有两个",{"2":{"6":1}}],["查看效果是否正确",{"2":{"6":1}}],["前端开发最常见的测试主要是以下几种",{"2":{"7":1}}],["前端开发人员在开发完一项功能后",{"2":{"6":1}}],["前端测试基础概念",{"0":{"3":1},"1":{"4":1,"5":1,"6":1,"7":1,"8":1,"9":1,"10":1,"11":1,"12":1,"13":1,"14":1,"15":1,"16":1}}],["促进重构",{"2":{"6":1}}],["促进开发人员思考",{"2":{"2":1}}],["改进设计",{"2":{"6":1}}],["稳定性的信心",{"2":{"6":1}}],["今早的发现程序的bug和不足",{"2":{"6":1}}],["虽然每一种方法的优势各不相同",{"2":{"6":1}}],["虽然有一部分手动测试时间是花在测试新特性上",{"2":{"5":1}}],["可维护的测试组合应该是这样的",{"2":{"12":1}}],["可以看到其在集成测试中的占比是最高的",{"2":{"12":1}}],["可以根据自己的需求随时运行它",{"2":{"10":1}}],["可以直接调用源代码里的函数",{"2":{"6":1}}],["可以编写浏览器自动执行的程序",{"2":{"6":1}}],["可使用许多种不同的方法来编写自动化测试脚本",{"2":{"6":1}}],["可测试性",{"2":{"2":1}}],["就是代码覆盖率",{"2":{"14":1}}],["就是用其他额外的代码检查被测软件的代码",{"2":{"6":1}}],["就可以不费吹灰之力的进行无数次重复测试",{"2":{"6":1}}],["换句话说",{"2":{"6":1}}],["计算机特别擅长此类工作",{"2":{"5":1}}],["幸运的是",{"2":{"5":1}}],["它关注的是在执行测试用例时",{"2":{"14":1}}],["它们不是互相排斥",{"2":{"16":1}}],["它们适用于不同的场景",{"2":{"16":1}}],["它们的本质是一致的",{"2":{"15":1}}],["它们的职责大致如下",{"2":{"12":1}}],["它们形式各异",{"2":{"14":1}}],["它们是重复性的",{"2":{"5":1}}],["它还告诉你每一层需要写多少测试",{"2":{"12":1}}],["它让你一眼就知道测试是需要分层的",{"2":{"12":1}}],["它是从程序员的角度编写的",{"2":{"12":1}}],["它的原理就是在编写代码之前先编写测试用例",{"2":{"1":1}}],["回归测试对人类来说是非常困难的任务",{"2":{"5":1}}],["这些度量工具有个特点",{"2":{"14":1}}],["这些部分应该使用什么方法进行测试",{"2":{"6":1}}],["这里",{"2":{"14":1}}],["这是一种面向软件开发和实现的定义",{"2":{"14":1}}],["这样一套测试代码可以节省多少时间",{"2":{"10":1}}],["这种虚拟使得测试成本最小化",{"2":{"8":1}}],["这种测试方法对确保应用程序代码变更后是否仍然可以正确渲染很有帮助",{"2":{"11":1}}],["这种测试太枯燥了",{"2":{"5":1}}],["这种测试被称为回归测试",{"2":{"5":1}}],["这也是自动化测试可以大展身手的地方",{"2":{"5":1}}],["这个比喻非常形象",{"2":{"12":1}}],["这个fix会不会引入其他",{"2":{"4":1}}],["这个feature会不会带来其他bug",{"2":{"4":1}}],["这个过程非常枯燥而痛苦",{"2":{"4":1}}],["这个函数如何使用",{"2":{"2":1}}],["大多数情况下",{"2":{"6":1,"16":1}}],["大多数情况下测试代码是功能代码的两倍甚至更多",{"2":{"2":1}}],["大部分时间都在做回归测试",{"2":{"5":1}}],["忘记测试某项功能",{"2":{"5":1}}],["手动不适合大型项目",{"2":{"5":1}}],["手动测试的优势在于足够简单灵活",{"2":{"5":1}}],["手动测试",{"0":{"5":1},"2":{"4":1}}],["但本质是相同",{"2":{"14":1}}],["但在前端应用中",{"2":{"8":1}}],["但这些问题不应该作为我们掌握前端自动化测试的绊脚石",{"2":{"6":1}}],["但它们有一大共同点",{"2":{"6":1}}],["但是大部分时间还是用来检查之前的特性是否仍正常工作",{"2":{"5":1}}],["但是缺点也很明显",{"2":{"5":1}}],["但你心里还是会犯嘀咕",{"2":{"4":1}}],["什么是应用程序测试",{"2":{"4":1}}],["解决它的根本原因就在于引入自动化测试方案",{"2":{"4":1}}],["以上这些问题都是由于大多数开发者所使用最基本的手动测试的方式所带来的问题",{"2":{"4":1}}],["你的应用就崩溃了",{"2":{"16":1}}],["你必须知道一个关键的概念",{"2":{"12":1}}],["你可以编写一个端到端测试",{"2":{"10":1}}],["你正在编写一个计算机应用程序",{"2":{"10":1}}],["你会花费大量的时间进行回归测试",{"2":{"4":1}}],["你应该会逐渐察觉到你在开发新功能或修复bug的时候",{"2":{"4":1}}],["quot",{"2":{"4":2}}],["即有意识的去收集这种数据",{"2":{"16":1}}],["即测试所覆盖的需求数量与总需求数量的比值",{"2":{"15":1}}],["即使代码看起来没什么问题",{"2":{"4":1}}],["即利用测试来驱动开发",{"2":{"2":1}}],["会变得越发小心翼翼",{"2":{"4":1}}],["当你调用一个api代码时",{"2":{"16":1}}],["当你想要对项目中的代码进行重构的时候",{"2":{"4":1}}],["当然",{"2":{"15":1,"16":1}}],["当然了自动化测试不可能保证一个程序是完全正确的",{"2":{"6":1}}],["当然不仅如此",{"2":{"6":1}}],["当测试代码编写完之后",{"2":{"6":1}}],["当维护者的数量不止你一个",{"2":{"4":1}}],["当代码的复杂度达到了一定的级别",{"2":{"4":1}}],["当业务代码变更的时候",{"2":{"2":1}}],["在底层为应用配置静态测试",{"2":{"12":1}}],["在奖杯模型中",{"2":{"12":1}}],["在编写代码逻辑阶段时进行报错提示",{"2":{"12":1}}],["在编写完源代码之后",{"2":{"5":1}}],["在前端应用程序中",{"2":{"10":1}}],["在实际开发过程中",{"2":{"6":1}}],["在日常的开发中",{"2":{"4":1}}],["在电脑前蹲上好几个小时甚至是更长时间对你的应用进行测试",{"2":{"4":1}}],["在测试通过后",{"2":{"2":1}}],["每一个称职的开发人员都懂得手动测试代码",{"2":{"5":1}}],["每次在版本发布上线之前",{"2":{"4":1}}],["每个函数应该只做它该做的事",{"2":{"2":1}}],["每个类",{"2":{"2":1}}],["每个代码单元的功能应该比较单纯",{"2":{"2":1}}],["每个用例不能使用其他用例的结果数据",{"2":{"2":1}}],["概述",{"0":{"4":1}}],["vue",{"2":{"2":1,"12":1}}],["比如一个不会经常变的公共方法就尽可能的将测试覆盖率做到趋于100",{"2":{"16":1}}],["比如jest自带了测试覆盖率统计",{"2":{"14":1}}],["比如使用eslint约束代码规范",{"2":{"12":1}}],["比如不存取数据库",{"2":{"8":1}}],["比如",{"2":{"6":1}}],["比如lodash",{"2":{"2":1}}],["比如只测试一个组件的某个功能点",{"2":{"1":1}}],["个人理解在前端应用实际开发过程中tdd更适合开发纯函数库",{"2":{"2":1}}],["无法保证多个单元组成的整体是否正常",{"2":{"2":1}}],["由于不关注底层代码实现细节",{"2":{"9":1}}],["由于是从用户使用角度出发",{"2":{"9":1}}],["由于单元测试是独立的",{"2":{"8":1}}],["由于单元测试只关注这一个单元的健康状况",{"2":{"2":1}}],["由测试来决定我们的代码",{"2":{"1":1}}],["业务耦合度高",{"2":{"2":1}}],["因此",{"2":{"15":1}}],["因此你可以在每次代码变更后都运行单元测试",{"2":{"8":1}}],["因此测试用例基本都能照顾到",{"2":{"2":1}}],["因为要不断的更改测试用例",{"2":{"16":1}}],["因为需求可能有遗漏或存在缺陷",{"2":{"15":1}}],["因为代码的执行顺序和函数的参数值",{"2":{"15":1}}],["因为后编写代码",{"2":{"2":1}}],["因为先编写测试",{"2":{"2":1}}],["软件开发是复杂性非常高的工作",{"2":{"2":1}}],["小步前进是降低复杂性的好办法",{"2":{"2":1}}],["小步前进",{"2":{"2":1}}],["味道",{"2":{"2":1}}],["对网络请求",{"2":{"12":1}}],["对应用中多个模块组织到一起的正确性进行测试",{"2":{"12":1}}],["对应用程序最小的部分",{"2":{"12":1}}],["对于需求覆盖率来说",{"2":{"15":1}}],["对于代码覆盖率来说",{"2":{"15":1}}],["对于黑盒测试",{"2":{"14":1,"15":1}}],["对于稍微有一些开发经验的同学在开发过程中总会经历下面类似的问题",{"2":{"4":1}}],["对于c++编程",{"2":{"2":1}}],["对于c代码或c++全局函数",{"2":{"2":1}}],["对结构不合理",{"2":{"2":1}}],["及时重构",{"2":{"2":1}}],["集成测试的开发速度要更快一些",{"2":{"9":1}}],["集成测试相对于写了软件的说明文档",{"2":{"9":1}}],["集成测试",{"0":{"9":1},"2":{"7":1,"12":4,"15":1}}],["集成",{"2":{"2":1}}],["随便在原有代码中添加功能",{"2":{"2":1}}],["各家自扫门前雪",{"2":{"2":1}}],["开发时的应尽可能提高可测试性",{"2":{"2":1}}],["开发过程包含多种工作",{"2":{"2":1}}],["产品代码设计",{"2":{"2":1}}],["编制一个高效的测试套件",{"2":{"6":1}}],["编码",{"2":{"2":1}}],["编写完一个端到端测试后",{"2":{"10":1}}],["编写自动化测试代码通常是开发人员不太喜欢的一个环节",{"2":{"6":1}}],["编写应用程序来替代人工检验",{"2":{"4":1}}],["编写产品代码",{"2":{"2":1}}],["编写测试代码时",{"2":{"2":1}}],["编写测试代码",{"2":{"2":1}}],["编写测试用例",{"2":{"1":1}}],["编写代码使测试通过",{"2":{"1":1}}],["明确这个类",{"2":{"2":1}}],["要调试端到端测试",{"2":{"10":1}}],["要求投入更多注意力",{"2":{"5":1}}],["要去重新组织测试用例",{"2":{"2":1}}],["要编写某个类或某个函数",{"2":{"2":1}}],["要实现某个功能",{"2":{"2":1}}],["是衡量软件测试完整性的一个重要指标",{"2":{"13":1}}],["是利用计算机程序检查软件是否运行正常的测试方法",{"2":{"6":1}}],["是tdd的核心",{"2":{"2":1}}],["是敏捷开发中的一项核心实践和技术",{"2":{"1":1}}],["避免疏漏",{"2":{"2":1}}],["应用程序中哪些部分应该被优先测试",{"2":{"6":1}}],["应用程序测试是指检查程序运行过程是否正确",{"2":{"4":1}}],["应及时进行重构",{"2":{"2":1}}],["应多考虑使用子类",{"2":{"2":1}}],["应该首先编写判断代码功能的断言语句",{"2":{"2":1}}],["应首先编写测试代码",{"2":{"2":1}}],["应把相关功能点加到测试列表中",{"2":{"2":1}}],["应专注于当前的角色",{"2":{"2":1}}],["任何阶段想添加功能时",{"2":{"2":1}}],["不代表所有情况被覆盖到",{"2":{"15":1}}],["不用花大力气搭建各种测试环境",{"2":{"8":1}}],["不访问网络等等",{"2":{"8":1}}],["不能保证代码能够正常运行",{"2":{"4":1}}],["不好的代码",{"2":{"2":1}}],["不要为了图一时之便",{"2":{"2":1}}],["不要弄成大杂烩",{"2":{"2":1}}],["不要过多考虑其他方面的细节",{"2":{"2":1}}],["不同代码的测试应该相互独立",{"2":{"2":1}}],["做不同的工作时",{"2":{"2":1}}],["如果你在开发一个极其重要的支付应用",{"2":{"16":1}}],["如果你是开发业务系统",{"2":{"12":1}}],["如果你是开发组件库",{"2":{"12":1}}],["如果你是开发纯函数库",{"2":{"12":1}}],["如果你真的想为你的软件构建自动化测试",{"2":{"12":1}}],["如果图像不同",{"2":{"11":1}}],["如果测试是在持续集成服务器上失败而不是本地计算机上失败",{"2":{"10":1}}],["如果应用程序完全依赖于端到端测试",{"2":{"10":1}}],["如果没有测试",{"2":{"4":1}}],["如何度量需求覆盖率呢",{"2":{"15":1}}],["如何度量代码覆盖率呢",{"2":{"14":1}}],["如何度量测试覆盖率呢",{"2":{"13":1}}],["如何进行前端应用测试",{"2":{"6":1}}],["如何进行应用程序测试",{"2":{"4":1}}],["如何测试",{"2":{"2":1}}],["如",{"2":{"2":1}}],["结果也不能依赖于用例执行顺序",{"2":{"2":1}}],["用例也应各自独立",{"2":{"2":1}}],["独立测试",{"2":{"2":1}}],["重复等",{"2":{"2":1}}],["重复上述步骤",{"2":{"1":1}}],["重载等oo方法",{"2":{"2":1}}],["重构",{"2":{"1":1}}],["新增功能",{"2":{"1":1}}],["运行测试的过程",{"2":{"8":1,"12":1}}],["运行测试",{"2":{"1":1}}],["某个工具函数等",{"2":{"1":1}}],["也可能是存在疑问的",{"2":{"15":1}}],["也可以直接对比程序渲染之后的截图",{"2":{"6":1}}],["也有些人认为任何完全渲染的组件测试都是集成测试",{"2":{"9":1}}],["也是一种软件设计方法论",{"2":{"1":1}}],["也能够影响软件开发的模式",{"2":{"0":1}}],["dots提出的the",{"2":{"12":1}}],["development",{"2":{"1":1}}],["driven",{"2":{"1":1}}],["typescript",{"2":{"12":1}}],["trophy",{"2":{"12":1}}],["to",{"2":{"10":1}}],["tape",{"2":{"8":1}}],["testing",{"2":{"6":1,"12":3}}],["test",{"2":{"1":1,"13":1}}],["tdd的缺点",{"2":{"2":1}}],["tdd的优点",{"2":{"2":1}}],["tdd的原则",{"0":{"2":1}}],["tdd开发流程",{"2":{"1":1}}],["tdd",{"0":{"1":1},"1":{"2":1},"2":{"0":1,"1":1}}],["先写断言",{"2":{"2":1}}],["先写测试后实现功能",{"2":{"0":1}}],["先实现功能后写测试",{"2":{"0":1}}],["行为驱动开发",{"2":{"0":1}}],["bdd",{"2":{"0":1}}],["测试也并非总能发现bug",{"2":{"16":1}}],["测试工作会有点像在黑灯瞎火中走路",{"2":{"16":1}}],["测试用例与需求之间的映射关系",{"2":{"15":1}}],["测试用例通常是基于软件需求而不是软件实现所设计的",{"2":{"15":1}}],["测试用例中使用了业务中一些模拟的数据",{"2":{"2":1}}],["测试覆盖率",{"0":{"13":1},"1":{"14":1,"15":1,"16":1},"2":{"13":1}}],["测试覆盖率高",{"2":{"2":1}}],["测试金字塔",{"2":{"12":1}}],["测试失败的时候无法快速定位问题",{"2":{"9":1}}],["测试的单元是函数",{"2":{"8":1}}],["测试分类",{"0":{"7":1}}],["测试驱动",{"2":{"2":1}}],["测试驱动开发",{"2":{"0":1,"1":1}}],["测试列表",{"2":{"2":1}}],["测试开发有两个流派",{"2":{"0":1}}],["测试开发方式",{"0":{"0":1},"1":{"1":1,"2":1}}],["测试不仅能够验证软件功能",{"2":{"0":1}}]],"serializationVersion":2}';export{t as default};
